# Subsystem
- Actuation(구동), Sensing(감지), Computing(계산) 이 3가지 범주로 나눌 수 있다.
- Actuation Subsystem : 바퀴 또는 팔이 움직이는 방법과 직접 상호 작용하는 시스템
- Sensing Subsystem : 카메라나 레이저 스캐너와 같은 센서 하드웨어와 직접 상호 작용하는 시스템
- Computing Subsystem : 로봇이 유용한 작업을 할 수 있도록 비교적 지능적 처리 및 액추에이터와 감지를 결합하는 것이다.
- 내가 알고 싶었던 것들만 정리하기로 한다.
## 1. Actuation : location Platform
- Ackerman Platform : 뒷바퀴는 항상 앞으로 똑바로 향하고, 앞바퀴들은 함께 회전하는 구조를 말한다. (승용차)
  - Non-holonomic : 주어진 시간에 아무 방향으로나 움직일 수 없다. -> Ackerman Platform의 단점
  - holonomic으로 만들어진 플랫폼으로 운동 계획을 단순화 할 수 있지만 더 복잡한 편이긴 하다고한다. (Mecanum Wheel)
- Location Platform에 경우에 관련 ROS 소프트웨어는 거의 항상 **Twist 메시지를 사용**한다.
  - Twist : 일반적 선 속도 및 각 속도를 3차원에서 표현하는 방법. **차 중심**에 대한 선 속도 및 각 속도를 사용하면 소프트웨어로 차량의 기구학을 추출/일반화 할 수 있다.
  - 예를 들어 0.1 rad/s 시계 방향 회전하면서 0.5 m/s 로 앞으로 구동하도록 명령 할 수 있는 것이다.
  - 이는 Differential drive 던지, Mecanum Wheel drive 던지 애커만이 던지 구동에 상관없다.
## 2. Sensor
### 광학카메라
- 보통 2D 카메라 이미지로 작업하는 것 보다 3D로 로봇 잡업과 환경을 설명하는 것이 보통 수학적으로 훨씬 더 견고하다고 한다.
- 3D 모습이 조명, 그림자 등에 불변하기 때문이라고 한다.
- 두 대의 카메라가 동일한 기계적 구조 위에 고정되어 세워지면 스테레오 카메라가 만들어 진다. 각 카메라는 약간 다른 시점으로 세계를 본다.
- 이들의 **미세한 차이**가 영상에서 다양한 특징에 대한 **거리를 추정하는 데 사용된**다.
  - 하지만 구별 가능한 특징인 표면이나 모서리만 가능하고, 어우선한 실내 장면에서는 매우 다를 수 있다.
- 영상에 대한 표준 ROS 메시지 자료형은 **sensor\_msgs/Image**이다.
  - 영상의 크기, 픽셀 부호화 구조, 픽셀 자체 만을 포함한다.
- ***고유한 왜곡 설명***을 위한 메시지는 sensor\_msgs/CameraInfo 메시지가 사용된다.
- 종종 ROS 영상은 OpenCV로부터 받거나 OpenCV 로 보내야한다.
  - cv\_bridge 패키지가 이런 작업을 단순화 시키도록 고안되어있다.
### 깊이카메라
- Data가 Point Cloud 형태를 가지며 많은 양의 데이터를 만들어낸다.
- **sensor\_msgs/PointCloud2** 라는 메시지를 기본적으로 사용한다.
  - 비구조적 PointCloud Data를 허용한다. 이는 영상에서 각 픽셀에 대한 유효한 깊이 추정치를 반환하지 않아 종종 유리하다고 한다.
    - 대충 데이터를 받아들여도 물체를 위치 등을 확인할 수 있어서 유용한 경우가 있다는 것 같다.
### 레이저 스케너
- 거리 추정 값을 만드는 데 필요한 복잡한 신호 처리 단계는 거의 항상 레이저 스캐너 자체의 펌웨어가 처리한다.
- 스캐너 장치는 시작 및 끝 각도까지의 거리 벡터를 보통 초당 수십 번 만든다.
- ROS에서 레이저 스캔 값은 **sensor\_msgs/LaserScan** 메시지에 저장된다.
### 축 인코더
- 가장 간단하고 가장 정확한 추정 값은 **바퀴 또는 모터가 얼마나 많이 회전했는지**를 숫자를 세서 얻는다. 이러한 목적으로 설계된 것이 축 인코더다.
- 다른 참조 프레임에 상대적인 운동을 측정한다.
- odometer : 주행기록계 처럼 축 인코더는 로봇 바퀴의 정확한 회전 수를 세고, 결국 차량이 얼마나 멀리 이동하였고 얼마나 많이 회전했는지를 추정하는 데 사용된다.
  - odometry : 주행기록, 단순히 구동 바퀴가 얼마나 많이 회전했는지를 나타낸다.
  - 위를 dead reckoning : 추측항법이라고도 부른다.
  - 로봇은 멀리 이동할 수록 편차가 계속 쌓일 것이다. 그러므로 지도를 작성하고 주행하기 위해 우수한 알고리즘이 필요한 이유다.
- 인코더 값은 이동체 장치 acuator 로 전달 되겠지만, odometry 추정값은 **geometry\_msgs/Transform** 메시지로 표현된 Spatial transform 값으로 전달될때 가장 유용하다.
  - Spatial Transform 은 일반적으로 다른 참조 프레임에 대해 상대적은 하나의 참조 프레임을 나타낸다.
  - Odometry Transform 은 전원 인가 하였을 때나 인코더가 마지막으로 초기화 되었을 때의 로봇 위치에 대해 상대적인 축 인코더의 Omdometry 추정값을 나타낸다.
## 3. Computing
- ROS는 POSIX프로세스 모델을 사용하여 구현된다.
- 한 노드로 부터 오는 메시지를 직렬화하고, 다른 노드로 프로세스 간 또는 네트워크 통신 방식으로 전송하고, 또 다른 노드를 위해 역직렬화 하려면 CPU 사이클이 분명히 요구 된다.
- 하지만, 이러한 비용 보다도 빠른 Prototyping, Software Intergraion에 대한 장점이 훨씬 크다고 판단한 것이다.
- ROS는 현재 리눅스 또는 맥 OS X와 같은 완전한 기능의 운영 체제에서 실행시켜야 한다.

